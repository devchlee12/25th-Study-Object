- 상속에 대한 오해 풀기
    - 상속은 두가지 용도로 사용됨
        - 타입 계층 구현
        - 코드 재사용
    - 하지만 유연한 설계를 위해서는 타입 계층 구현을 목표로 사용해야함
    - 단순 코드 재사용으로 상속 사용하면 부모와 자식 강결합
- 이번장에서는 타입계층을 올바르게 구성하는 원칙을 살펴봄

### 타입

- 개념관점의 타입
    - 인지하는 세상의 사물의 종류
    - 구성요소
        - 심볼 - 이름
        - 내연 - 타입에 속하는 객체들의 공통 속성이나 행동
        - 외연 - 타입에 속하는 객체 집합
- 프로그래밍 언어 관점의 타입
    - 타입에 수행될 수 있는 오퍼레이션 집합 정의
    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥 제공
- 객체지향 패러다임 관점의 타입
    - 호출가능한 오퍼레이션의 집합
    - 곧, 타입은 퍼블릭 인터페이스라는 뜻

### 타입 계층

- 타입 사이의 포함관계
    - 타입 사이에는 포함관계가 성립할 수 있고, 이를 타입계층으로 표현 가능
    - 슈퍼타입
        - 집합이 다른 집합의 모든 멤버 포함
        - 타입 정의가 다른 타입보다 일반적
    - 서브타입
        - 집합에 포함되는 인스턴스가 더 큰 집합에 포함
        - 타입 정의가 다른 타입보다 구체적
- 객체 지향 프로그래밍과 타입 계층
    - 일반적인 타입과 구체적인 타입간의 관계 형성 기준 → 퍼블릭 인터페이스

### 서브 클래싱과 서브 타이핑

- 언제 상속을 사용해야하는가? - 두 조건 만족시킬 때만 상속 사용해야함
    - 상속관계가 is-a 관계를 모델링할 때
    - 클라이언트 입장에서 부모 클래스 타입으로 자식 클래스 사용해도 무방할 때
- is-a 관계
    - ex) 객체지향 언어는 프로그래밍 언어다
    - 하지만 의외로 is-a관계는 생각보다 직관적이지 않음
        - 펭귄의 예
            - 펭귄은 새다
            - 새는 날 수 있다
        - 언어적으로는 위 관계가 맞지만, 펭귄은 날 수 없다.
        - 따라서 is-a 관계를 판단할 떄는 기대되는 행동에 따라 판단해야한다.
- 행동호환성
    - 행동이 호환된다는것은 무슨뜻인가
        - 클라이언트 관점에서 동일하게 행동할 것이라고 기대하는 것
    - 따라서 클라이언트의 기대에 따라 계층을 분리해야함
        - 예를 들어 Bird 하위에 FlyingBird 계층을 두는 것
    - 또는 클라이언트에 따라 인터페이스 분리
        - Flyer와 Walker 인터페이스를 각각 생성하고 필요한 만큼 구현
        - 펭귄이 만약 Bird의 코드를 재사용하고 싶다면 상속이 아니라 합성 사용
        - 인터페이스 분리 원칙을 지키는 것
- 서브클래싱과 서브 타이핑
    - 서브클래싱 → 다른 클래스의 코드 재사용 목적으로 상속 사용(자식과 부모 클래스 행동이 호환 안됨) - 클래스 상속
    - 서브 타이핑 → 타입계층 구성위해 상속 사용 - 인터페이스 상속
    - 상속이 나쁜게 아니라 서브클래싱이 나쁜거임.

### 리스코프 치환 원칙

- 서브타입은 기반 타입에 대해 대체 가능해야 한다.
    - 행동 호환성을 설계원칙으로 정리한 것
- 정사각형은 직사각형인가? - 리스코프 치환원칙을 위반하는 사례
    - 정사각형은 직사각형을 대체하지 못함
    - resize 했을 때 클라이언트의 기대대로 행동하지 않음
        - 가로세로가 다를 수 없어서
    - 그래서 이건 서브클래싱 관계임
- 대체 가능성을 결정하는 것은 클라이언트
- 리스코프 치환 원칙은 유연한 설계의 기반
    - 새로운 자식 클래스 추가하더라도 클라이언트 입장에서 동일하게 행동만 하면 상속계층 확장 가능

### 계약에 의한 설계와 서브타이핑

- 계약에 의한 설계
    - 클라이언트와 서버 사이 협력을 의무와 이익으로 구성된 계약 관점에서 표현
    - 구성 요소
        - 사전 조건 → 메서드 실행전 만족
        - 사후 조건 → 메서드 실행 후 만족
        - 클래스 불변식 → 실행전과후에 만족
- 계약에 의한 설계로 리스코프 치환 원칙조건을 명확하게 설명 가능
    - 서브타입이 리스코프 치환 원칙 만족시키려면 클라이언트와 슈퍼 타입 간에 체결된 계약 준수해야함
    - 명확히 명세하자면?
        - 서브타입에 강력한 사전조건 정의 불가
        - 서브타입에 더 약한 사후 조건 정의 불가
